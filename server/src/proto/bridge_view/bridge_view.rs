// @generated
// This file is @generated by prost-build.
/// Client registration request
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ClientRegistration {
    /// Unique client identifier
    #[prost(string, tag="1")]
    pub client_id: ::prost::alloc::string::String,
    /// Type of device (phone, laptop)
    #[prost(enumeration="DeviceType", tag="2")]
    pub device_type: i32,
    /// Human-readable device name
    #[prost(string, tag="3")]
    pub device_name: ::prost::alloc::string::String,
    /// Client capabilities
    #[prost(message, optional, tag="4")]
    pub capabilities: ::core::option::Option<ClientCapabilities>,
}
/// Client capabilities
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ClientCapabilities {
    /// Maximum display width
    #[prost(uint32, tag="1")]
    pub max_width: u32,
    /// Maximum display height
    #[prost(uint32, tag="2")]
    pub max_height: u32,
    /// Supported video codecs
    #[prost(enumeration="VideoCodec", repeated, tag="3")]
    pub supported_codecs: ::prost::alloc::vec::Vec<i32>,
    /// Supports touch input
    #[prost(bool, tag="4")]
    pub supports_touch: bool,
    /// Supports keyboard input
    #[prost(bool, tag="5")]
    pub supports_keyboard: bool,
    /// Supports mouse input
    #[prost(bool, tag="6")]
    pub supports_mouse: bool,
    /// Maximum supported frame rate
    #[prost(uint32, tag="7")]
    pub max_framerate: u32,
}
/// Display configuration sent to client
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DisplayConfig {
    /// Session identifier
    #[prost(string, tag="1")]
    pub session_id: ::prost::alloc::string::String,
    /// Display width in pixels
    #[prost(uint32, tag="2")]
    pub display_width: u32,
    /// Display height in pixels
    #[prost(uint32, tag="3")]
    pub display_height: u32,
    /// Target frame rate
    #[prost(uint32, tag="4")]
    pub framerate: u32,
    /// Video codec to use
    #[prost(enumeration="VideoCodec", tag="5")]
    pub codec: i32,
    /// Position in extended desktop
    #[prost(message, optional, tag="6")]
    pub position: ::core::option::Option<DisplayPosition>,
    /// Compression settings
    #[prost(message, optional, tag="7")]
    pub compression: ::core::option::Option<CompressionSettings>,
}
/// Display position in extended desktop
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DisplayPosition {
    /// X offset from primary display
    #[prost(int32, tag="1")]
    pub x_offset: i32,
    /// Y offset from primary display
    #[prost(int32, tag="2")]
    pub y_offset: i32,
    /// Width of display region
    #[prost(uint32, tag="3")]
    pub width: u32,
    /// Height of display region
    #[prost(uint32, tag="4")]
    pub height: u32,
}
/// Compression settings
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CompressionSettings {
    /// Target bitrate in kbps
    #[prost(uint32, tag="1")]
    pub bitrate_kbps: u32,
    /// Quality level (0-100)
    #[prost(uint32, tag="2")]
    pub quality: u32,
    /// Enable adaptive bitrate
    #[prost(bool, tag="3")]
    pub adaptive_bitrate: bool,
}
/// Frame request from client
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FrameRequest {
    /// Session identifier
    #[prost(string, tag="1")]
    pub session_id: ::prost::alloc::string::String,
    /// Last received frame sequence number
    #[prost(uint64, tag="2")]
    pub last_frame_sequence: u64,
    /// Type of request
    #[prost(enumeration="FrameRequestType", tag="3")]
    pub request_type: i32,
}
/// Video frame data
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct VideoFrame {
    /// Frame sequence number
    #[prost(uint64, tag="1")]
    pub sequence_number: u64,
    /// Timestamp in microseconds
    #[prost(uint64, tag="2")]
    pub timestamp_us: u64,
    /// Encoded frame data
    #[prost(bytes="vec", tag="3")]
    pub frame_data: ::prost::alloc::vec::Vec<u8>,
    /// Type of frame (keyframe, etc.)
    #[prost(enumeration="FrameType", tag="4")]
    pub frame_type: i32,
    /// Frame width
    #[prost(uint32, tag="5")]
    pub width: u32,
    /// Frame height
    #[prost(uint32, tag="6")]
    pub height: u32,
}
/// Input event from client to server
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InputEvent {
    /// Session identifier
    #[prost(string, tag="1")]
    pub session_id: ::prost::alloc::string::String,
    /// Timestamp in microseconds
    #[prost(uint64, tag="2")]
    pub timestamp_us: u64,
    #[prost(oneof="input_event::Event", tags="3, 4, 5")]
    pub event: ::core::option::Option<input_event::Event>,
}
/// Nested message and enum types in `InputEvent`.
pub mod input_event {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag="3")]
        Mouse(super::MouseEvent),
        #[prost(message, tag="4")]
        Keyboard(super::KeyboardEvent),
        #[prost(message, tag="5")]
        Touch(super::TouchEvent),
    }
}
/// Mouse event
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MouseEvent {
    /// Event type
    #[prost(enumeration="MouseEventType", tag="1")]
    pub r#type: i32,
    /// X coordinate (normalized 0-1)
    #[prost(float, tag="2")]
    pub x: f32,
    /// Y coordinate (normalized 0-1)
    #[prost(float, tag="3")]
    pub y: f32,
    /// Button pressed
    #[prost(enumeration="MouseButton", tag="4")]
    pub button: i32,
    /// Horizontal scroll delta
    #[prost(int32, tag="5")]
    pub scroll_delta_x: i32,
    /// Vertical scroll delta
    #[prost(int32, tag="6")]
    pub scroll_delta_y: i32,
    /// Keyboard modifiers
    #[prost(message, optional, tag="7")]
    pub modifiers: ::core::option::Option<KeyModifiers>,
}
/// Keyboard event
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct KeyboardEvent {
    /// Event type
    #[prost(enumeration="KeyboardEventType", tag="1")]
    pub r#type: i32,
    /// Key code
    #[prost(uint32, tag="2")]
    pub key_code: u32,
    /// Character representation
    #[prost(string, tag="3")]
    pub key_char: ::prost::alloc::string::String,
    /// Keyboard modifiers
    #[prost(message, optional, tag="4")]
    pub modifiers: ::core::option::Option<KeyModifiers>,
}
/// Keyboard modifiers
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct KeyModifiers {
    #[prost(bool, tag="1")]
    pub shift: bool,
    #[prost(bool, tag="2")]
    pub ctrl: bool,
    #[prost(bool, tag="3")]
    pub alt: bool,
    /// Command on macOS, Windows key on Windows
    #[prost(bool, tag="4")]
    pub meta: bool,
}
/// Touch event
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TouchEvent {
    /// Event type
    #[prost(enumeration="TouchEventType", tag="1")]
    pub r#type: i32,
    /// Touch points
    #[prost(message, repeated, tag="2")]
    pub touches: ::prost::alloc::vec::Vec<TouchPoint>,
}
/// Touch point
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TouchPoint {
    /// Touch point identifier
    #[prost(uint32, tag="1")]
    pub id: u32,
    /// X coordinate (normalized 0-1)
    #[prost(float, tag="2")]
    pub x: f32,
    /// Y coordinate (normalized 0-1)
    #[prost(float, tag="3")]
    pub y: f32,
    /// Pressure (0-1)
    #[prost(float, tag="4")]
    pub pressure: f32,
}
/// Input response
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InputResponse {
    /// Whether input was processed
    #[prost(bool, tag="1")]
    pub success: bool,
    /// Error message if failed
    #[prost(string, tag="2")]
    pub error_message: ::prost::alloc::string::String,
}
/// Control message
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ControlMessage {
    /// Session identifier
    #[prost(string, tag="1")]
    pub session_id: ::prost::alloc::string::String,
    /// Type of control message
    #[prost(enumeration="ControlMessageType", tag="2")]
    pub r#type: i32,
    /// Optional payload data
    #[prost(string, tag="3")]
    pub payload: ::prost::alloc::string::String,
}
/// Control response
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ControlResponse {
    /// Whether control message was processed
    #[prost(bool, tag="1")]
    pub success: bool,
    /// Response message
    #[prost(string, tag="2")]
    pub message: ::prost::alloc::string::String,
    /// Server timestamp for heartbeat
    #[prost(uint64, tag="3")]
    pub timestamp_us: u64,
}
/// Device type enumeration
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DeviceType {
    Unspecified = 0,
    AndroidPhone = 1,
    MacosLaptop = 2,
    IosPhone = 3,
}
impl DeviceType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "DEVICE_TYPE_UNSPECIFIED",
            Self::AndroidPhone => "DEVICE_TYPE_ANDROID_PHONE",
            Self::MacosLaptop => "DEVICE_TYPE_MACOS_LAPTOP",
            Self::IosPhone => "DEVICE_TYPE_IOS_PHONE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DEVICE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "DEVICE_TYPE_ANDROID_PHONE" => Some(Self::AndroidPhone),
            "DEVICE_TYPE_MACOS_LAPTOP" => Some(Self::MacosLaptop),
            "DEVICE_TYPE_IOS_PHONE" => Some(Self::IosPhone),
            _ => None,
        }
    }
}
/// Video codec enumeration
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VideoCodec {
    Unspecified = 0,
    H264 = 1,
    H265 = 2,
    Vp8 = 3,
    Vp9 = 4,
}
impl VideoCodec {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "VIDEO_CODEC_UNSPECIFIED",
            Self::H264 => "VIDEO_CODEC_H264",
            Self::H265 => "VIDEO_CODEC_H265",
            Self::Vp8 => "VIDEO_CODEC_VP8",
            Self::Vp9 => "VIDEO_CODEC_VP9",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VIDEO_CODEC_UNSPECIFIED" => Some(Self::Unspecified),
            "VIDEO_CODEC_H264" => Some(Self::H264),
            "VIDEO_CODEC_H265" => Some(Self::H265),
            "VIDEO_CODEC_VP8" => Some(Self::Vp8),
            "VIDEO_CODEC_VP9" => Some(Self::Vp9),
            _ => None,
        }
    }
}
/// Frame request type
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FrameRequestType {
    Unspecified = 0,
    /// Continue streaming
    Continue = 1,
    /// Request keyframe
    Keyframe = 2,
    /// Pause streaming
    Pause = 3,
    /// Resume streaming
    Resume = 4,
}
impl FrameRequestType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "FRAME_REQUEST_TYPE_UNSPECIFIED",
            Self::Continue => "FRAME_REQUEST_TYPE_CONTINUE",
            Self::Keyframe => "FRAME_REQUEST_TYPE_KEYFRAME",
            Self::Pause => "FRAME_REQUEST_TYPE_PAUSE",
            Self::Resume => "FRAME_REQUEST_TYPE_RESUME",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FRAME_REQUEST_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "FRAME_REQUEST_TYPE_CONTINUE" => Some(Self::Continue),
            "FRAME_REQUEST_TYPE_KEYFRAME" => Some(Self::Keyframe),
            "FRAME_REQUEST_TYPE_PAUSE" => Some(Self::Pause),
            "FRAME_REQUEST_TYPE_RESUME" => Some(Self::Resume),
            _ => None,
        }
    }
}
/// Frame type enumeration
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FrameType {
    Unspecified = 0,
    /// I-frame / keyframe
    Keyframe = 1,
    /// P-frame / delta frame
    Delta = 2,
}
impl FrameType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "FRAME_TYPE_UNSPECIFIED",
            Self::Keyframe => "FRAME_TYPE_KEYFRAME",
            Self::Delta => "FRAME_TYPE_DELTA",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FRAME_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "FRAME_TYPE_KEYFRAME" => Some(Self::Keyframe),
            "FRAME_TYPE_DELTA" => Some(Self::Delta),
            _ => None,
        }
    }
}
/// Mouse event type
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MouseEventType {
    Unspecified = 0,
    Move = 1,
    Down = 2,
    Up = 3,
    Scroll = 4,
    Drag = 5,
}
impl MouseEventType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "MOUSE_EVENT_TYPE_UNSPECIFIED",
            Self::Move => "MOUSE_EVENT_TYPE_MOVE",
            Self::Down => "MOUSE_EVENT_TYPE_DOWN",
            Self::Up => "MOUSE_EVENT_TYPE_UP",
            Self::Scroll => "MOUSE_EVENT_TYPE_SCROLL",
            Self::Drag => "MOUSE_EVENT_TYPE_DRAG",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MOUSE_EVENT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "MOUSE_EVENT_TYPE_MOVE" => Some(Self::Move),
            "MOUSE_EVENT_TYPE_DOWN" => Some(Self::Down),
            "MOUSE_EVENT_TYPE_UP" => Some(Self::Up),
            "MOUSE_EVENT_TYPE_SCROLL" => Some(Self::Scroll),
            "MOUSE_EVENT_TYPE_DRAG" => Some(Self::Drag),
            _ => None,
        }
    }
}
/// Mouse button
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MouseButton {
    Unspecified = 0,
    Left = 1,
    Right = 2,
    Middle = 3,
}
impl MouseButton {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "MOUSE_BUTTON_UNSPECIFIED",
            Self::Left => "MOUSE_BUTTON_LEFT",
            Self::Right => "MOUSE_BUTTON_RIGHT",
            Self::Middle => "MOUSE_BUTTON_MIDDLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MOUSE_BUTTON_UNSPECIFIED" => Some(Self::Unspecified),
            "MOUSE_BUTTON_LEFT" => Some(Self::Left),
            "MOUSE_BUTTON_RIGHT" => Some(Self::Right),
            "MOUSE_BUTTON_MIDDLE" => Some(Self::Middle),
            _ => None,
        }
    }
}
/// Keyboard event type
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum KeyboardEventType {
    Unspecified = 0,
    Down = 1,
    Up = 2,
    Press = 3,
}
impl KeyboardEventType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "KEYBOARD_EVENT_TYPE_UNSPECIFIED",
            Self::Down => "KEYBOARD_EVENT_TYPE_DOWN",
            Self::Up => "KEYBOARD_EVENT_TYPE_UP",
            Self::Press => "KEYBOARD_EVENT_TYPE_PRESS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "KEYBOARD_EVENT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "KEYBOARD_EVENT_TYPE_DOWN" => Some(Self::Down),
            "KEYBOARD_EVENT_TYPE_UP" => Some(Self::Up),
            "KEYBOARD_EVENT_TYPE_PRESS" => Some(Self::Press),
            _ => None,
        }
    }
}
/// Touch event type
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TouchEventType {
    Unspecified = 0,
    Down = 1,
    Move = 2,
    Up = 3,
    Cancel = 4,
}
impl TouchEventType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "TOUCH_EVENT_TYPE_UNSPECIFIED",
            Self::Down => "TOUCH_EVENT_TYPE_DOWN",
            Self::Move => "TOUCH_EVENT_TYPE_MOVE",
            Self::Up => "TOUCH_EVENT_TYPE_UP",
            Self::Cancel => "TOUCH_EVENT_TYPE_CANCEL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TOUCH_EVENT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "TOUCH_EVENT_TYPE_DOWN" => Some(Self::Down),
            "TOUCH_EVENT_TYPE_MOVE" => Some(Self::Move),
            "TOUCH_EVENT_TYPE_UP" => Some(Self::Up),
            "TOUCH_EVENT_TYPE_CANCEL" => Some(Self::Cancel),
            _ => None,
        }
    }
}
/// Control message type
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ControlMessageType {
    Unspecified = 0,
    /// Heartbeat/ping
    Heartbeat = 1,
    /// Graceful disconnect
    Disconnect = 2,
    /// Request reconfiguration
    Reconfigure = 3,
    /// Error notification
    Error = 4,
}
impl ControlMessageType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CONTROL_MESSAGE_TYPE_UNSPECIFIED",
            Self::Heartbeat => "CONTROL_MESSAGE_TYPE_HEARTBEAT",
            Self::Disconnect => "CONTROL_MESSAGE_TYPE_DISCONNECT",
            Self::Reconfigure => "CONTROL_MESSAGE_TYPE_RECONFIGURE",
            Self::Error => "CONTROL_MESSAGE_TYPE_ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CONTROL_MESSAGE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "CONTROL_MESSAGE_TYPE_HEARTBEAT" => Some(Self::Heartbeat),
            "CONTROL_MESSAGE_TYPE_DISCONNECT" => Some(Self::Disconnect),
            "CONTROL_MESSAGE_TYPE_RECONFIGURE" => Some(Self::Reconfigure),
            "CONTROL_MESSAGE_TYPE_ERROR" => Some(Self::Error),
            _ => None,
        }
    }
}
// @@protoc_insertion_point(module)
